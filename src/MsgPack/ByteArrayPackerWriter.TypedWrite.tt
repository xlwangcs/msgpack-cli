<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ include file=".\PackerWriter.TypedWrite.ttinclude" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.Text" #>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2017 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

#if UNITY_5 || UNITY_STANDALONE || UNITY_WEBPLAYER || UNITY_WII || UNITY_IPHONE || UNITY_ANDROID || UNITY_PS3 || UNITY_XBOX360 || UNITY_FLASH || UNITY_BKACKBERRY || UNITY_WINRT
#define UNITY
#endif

using System;
#if CORE_CLR || UNITY || NETSTANDARD1_1
using Contract = MsgPack.MPContract;
#else
using System.Diagnostics.Contracts;
#endif // CORE_CLR || UNITY || NETSTANDARD1_1
using System.Text;
#if FEATURE_TAP
using System.Threading;
using System.Threading.Tasks;
#endif // FEATURE_TAP

namespace MsgPack
{
	// This file was generated from ByteArrayPackerWriter.TypedWrite.tt and PackerWriter.TypedWrite.ttinclude T4Template.
	// Do not modify this file. Edit ByteArrayPackerWriter.TypedWrite.tt and PackerWriter.TypedWrite.ttinclude instead.

	partial class ByteArrayPackerWriter
	{
<#
	foreach ( var isAsync in new [] { false, true } )
	{
		if ( isAsync )
		{
#>
#if FEATURE_TAP

<#
		}

		foreach ( var type in scalarTypes )
		{
#>
		public override <#= isAsync ? "Task" : "void" #> WriteBytes<#= isAsync ? "Async" : String.Empty #>( byte header, <#= type #> value<#= isAsync ? ", CancellationToken cancellationToken" : String.Empty #> )
		{
<#
			if ( isAsync )
			{
#>
			this.WriteBytes( header, value );
			return TaskAugument.CompletedTask;
<#
			}
			else
			{
				string bits;
				this.WriteToBits( type, "value", out bits );
#>
			var currentBuffer = this._currentBuffer;
			var currentBufferIndex = this._currentBufferIndex;
			if ( !this.ShiftBufferIfNeeded( sizeof( <#= type #> ) + 1, ref currentBuffer, ref currentBufferIndex ) )
			{
				this.ThrowEofException( sizeof( <#= type #> ) );
			}

			currentBuffer.Array[ currentBuffer.Offset ] = header;
			currentBuffer = currentBuffer.Slice( 1 );
			
			if ( !this.ShiftBufferIfNeeded( sizeof( <#= type #> ), ref currentBuffer, ref currentBufferIndex ) )
			{
				this.ThrowEofException( sizeof( <#= type #> ) );
			}

			var buffer = currentBuffer.Array;
			var offset = currentBuffer.Offset;
			var bufferRemaining = currentBuffer.Count;

			for ( var totalWritten = 0; totalWritten < sizeof( <#= type #> ); )
			{
				var currentWritten = 0;
				for ( ; currentWritten < bufferRemaining && totalWritten < sizeof( <#= type #> ); currentWritten++, totalWritten++ )
				{
					buffer[ offset + currentWritten ] = unchecked( ( byte )( <#= bits #> >> ( ( sizeof( <#= type #> ) - totalWritten - 1 ) * 8 ) & 0xFF ) );
				}

				currentBuffer = currentBuffer.Slice( currentWritten );
			
				if ( !this.ShiftBufferIfNeeded( sizeof( <#= type #> ) - totalWritten, ref currentBuffer, ref currentBufferIndex ) )
				{
					this.ThrowEofException( sizeof( <#= type #> ) );
				}

				buffer = currentBuffer.Array;
				offset = currentBuffer.Offset;
				bufferRemaining = currentBuffer.Count;
			}

			this._currentBufferIndex = currentBufferIndex;
			this._currentBuffer = currentBuffer;
<#
			} // if isAsync 
#>
		}

<#
		} // foreach type
#>
		public override <#= isAsync ? "Task" : "void" #> WriteBytes<#= isAsync ? "Async" : String.Empty #>( string value, bool allowStr8<#= isAsync ? ", CancellationToken cancellationToken" : String.Empty #> )
		{
<#
			if ( isAsync )
			{
#>
			this.WriteBytes( value, allowStr8 );
			return TaskAugument.CompletedTask;
<#
			}
			else
			{
#>
			var chars = value.ToCharArray();
			var encoder = Encoding.UTF8.GetEncoder();
			this.WriteStringHeader( encoder.GetByteCount( chars, 0, chars.Length, true ), allowStr8 );
			
			var currentBuffer = this._currentBuffer;
			var currentBufferIndex = this._currentBufferIndex;
			int charsOffset = 0;
			int remainingCharLength = value.Length;
			bool isCompleted = false;
			do
			{
				if ( !this.ShiftBufferIfNeeded( remainingCharLength * sizeof( char ), ref currentBuffer, ref currentBufferIndex ) )
				{
					this.ThrowEofExceptionForString( ( value.Length - remainingCharLength ) * sizeof( char ) );
				}

				int bytesUsed;
				isCompleted = encoder.EncodeString( chars, ref charsOffset, ref remainingCharLength, currentBuffer.Array, currentBuffer.Offset, currentBuffer.Count, out bytesUsed );
				currentBuffer = currentBuffer.Slice( bytesUsed );
			} while ( remainingCharLength > 0 );

#if DEBUG
			Contract.Assert( isCompleted, "Encoding is not completed!" );
#endif // DEBUG

			this._currentBufferIndex = currentBufferIndex;
			this._currentBuffer = currentBuffer;
<#
			} // if isAsync
#>
		}

<#

		if ( isAsync )
		{
#>
#endif // FEATURE_TAP
<#
		}
	} // foreach isAsync
#>
		private void WriteStringHeader( int bytesLength, bool allowStr8 )
		{
			if( bytesLength < 0x20 )
			{
				this.WriteByte( ( byte )( bytesLength | MessagePackCode.MinimumFixedRaw ) );
				return;
			}

			if ( bytesLength < 0x100 && allowStr8 )
			{
				this.WriteBytes( MessagePackCode.Str8, ( byte )bytesLength );
				return;
			}

			if ( bytesLength < 0x10000 )
			{
				this.WriteBytes( MessagePackCode.Str16, ( ushort )bytesLength );
				return;
			}

			this.WriteBytes( MessagePackCode.Str32, unchecked(( uint )bytesLength) );
		}
	}
}