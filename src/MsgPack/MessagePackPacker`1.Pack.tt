<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.Text" #>
<#@ include file="..\Core.ttinclude" #>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2017 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

using System;
using System.Collections.Generic;
#if FEATURE_TAP
using System.Threading;
using System.Threading.Tasks;
#endif // FEATURE_TAP

namespace MsgPack
{
	// This file was generated from MessagePackPacker`1.Pack.tt and Core.ttinclude T4Template.
	// Do not modify this file. Edit MessagePackPacker`1.Pack.tt  and Core.ttinclude instead.

	partial class MessagePackPacker<TWriter>
	{
<#
var ints =
	new HashSet<Type>
	{
		typeof( byte ), typeof( sbyte ),
		typeof( short ), typeof( ushort ),
		typeof( int ), typeof( uint ),
		typeof( long ), typeof( ulong ),
	};

var signedInts =
	new HashSet<Type>
	{
		typeof( sbyte ),
		typeof( short ),
		typeof( int ),
		typeof( long ), 
	};

foreach ( var isAsync in new [] { false, true } )
{
	if ( isAsync )
	{
#>
#if FEATURE_TAP

<#
	}

	foreach ( var type in
		new []
		{ 
			typeof( bool ), 
			typeof( byte ), typeof( sbyte ),
			typeof( short ), typeof( ushort ),
			typeof( int ), typeof( uint ),
			typeof( long ), typeof( ulong ),
			typeof( float ), typeof( double ),
		}
	)
	{
		foreach ( var isNullable in new [] { false, true } )
		{
#>
		public <#= AsyncPack( type, isAsync, isNullable ) #>
		{
<#
			if ( isNullable )
			{
#>
			if ( nullable == null )
			{
				<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( Header.Nil<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			var value = nullable.GetValueOrDefault();

<#
			} // if isNullable

			if ( ints.Contains( type ) )
			{
				if ( type.Name.EndsWith( "64" ) )
				{
#>
			if ( ( value & 0x000000000000007FL ) == value )
<#
				}
				else
				{
#>
			if ( ( value & 0x0000007F ) == value )
<#
				}
#>
			{
				// Positive fix num
				<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( unchecked( ( byte )( value & 0xFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

<#
			} // if ints
			
			if ( signedInts.Contains( type ) )
			{
				if ( type.Name.EndsWith( "64" ) )
				{
#>
			if ( ( ~value & unchecked( ( long )0xFFFFFFFFFFFFFFE0 ) ) == 0 )
<#
				}
				else
				{
#>
			if ( ( ~value & 0xFFFFFFE0 ) == 0 )
<#
				}
#>
			{
				// Negative fix num
				<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( unchecked( ( byte )( value & 0xFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

<#
			} // if signedInts

			if ( type == typeof( bool ) )
			{
#>
			<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( value ? Header.True : Header.False<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
<#
			}
			else
			{
				if ( ints.Contains( type ) )
				{
					// Use compact expression as possible

					var size = Marshal.SizeOf( type );
					var isSigned = signedInts.Contains( type );

					if ( isSigned )
					{
#>
			if ( value < 0 )
			{
<#
						for ( var bytes = 1; bytes < size; bytes *= 2 )
						{
							var mask = new String( Enumerable.Repeat( 'F', bytes * 2 ).ToArray() );
#>
				if ( value >= <#= ToTypeName( true, bytes ) #>.MinValue )
				{
					<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= ToTypeName( isSigned, bytes ) #>, unchecked( ( <#= ToTypeName( false, bytes ) #> )( value & 0x<#= mask #> ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
					return;
				}

<#
						} // for
#>
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= type.Name #>, unchecked( ( <#= ToUnsigned( type ) #> )value )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

<#
					} // isSigned

					for ( var bytes = 1; bytes < size; bytes *= 2 )
					{
						var mask = new String( Enumerable.Repeat( 'F', bytes * 2 ).ToArray() );
#>
			if ( value <= <#= ToTypeName( isSigned, bytes ) #>.MaxValue )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= ToTypeName( isSigned, bytes ) #>, unchecked( ( <#= ToTypeName( false, bytes ) #> )( value & 0x<#= mask #> ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

<#
					} // for
				} // if ints
#>
			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= type.Name #>, unchecked( ( <#= ToUnsigned( type ) #> )value )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
<#
			} // if type == typeof( bool )
#>
		}

<#
		} // foreach isNullable
	} // foreach type (scalar)

	foreach ( var prefix in new [] { "Array", "Map" } )
	{
#>
		public <#= AsyncMethod( isAsync, "void", "Pack" + prefix + "Header", "uint count" ) #>
		{
			if ( count < 0x10 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( unchecked( ( byte )( MessagePackCode.MinimumFixed<#= prefix #> | count ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			if ( count < 0x10000 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= prefix #>16, unchecked( ( ushort )( count & 0xFFFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= prefix #>32, unchecked( ( uint )count )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
			return;
		}

<#
	} // foreach prefix

#>
		public <#= AsyncMethod( isAsync, "void", "PackStringHeader", "uint count" ) #>
		{
			if ( count < 0x20 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | count ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			if ( count < 0x100 && this.AllowStr8 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Str8, unchecked( ( byte )( count & 0xFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			if ( count < 0x10000 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Str16, unchecked( ( ushort )( count & 0xFFFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Str32, unchecked( ( uint )count )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
			return;
		}

		public <#= AsyncMethod( isAsync, "void", "PackBinaryHeader", "uint count" ) #>
		{
			if ( count < 0x100 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Bin8, unchecked( ( byte )( count & 0xFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			if ( count < 0x10000 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Bin16, unchecked( ( ushort )( count & 0xFFFF ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Bin32, unchecked( ( uint )count )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
			return;
		}

<#

	// TODO: ReadOnlySpan<char>, ReadOnlySpan<byte>

#>
		public <#= AsyncMethod( isAsync, "void", "PackRaw", "string value" ) #>
		{
			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( value, this.AllowStr8<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
		}

<#

	foreach ( var isRaw in new [] { true, false } )
	{
		var suffix = isRaw ? "Raw" : "Binary";
		var code = isRaw ? "Str" : "Bin";
#>
		public <#= AsyncMethod( isAsync, "void", "Pack" + suffix, "byte[] value" ) #>
		{
<#
		if ( isRaw )
		{
#>
			if ( value.Length < 0x20 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | value.Length ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( value<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

<#
		} // if spec.IsRaw
#>
			if ( value.Length < 0x100<#= isRaw ? " && this.AllowStr8" : String.Empty #> )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= code #>8, unchecked( ( byte )( value.Length ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( value<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			if ( value.Length < 0x10000 )
			{
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= code #>16, unchecked( ( ushort )( value.Length ) )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( value<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
				return;
			}

			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.<#= code #>32, unchecked( ( uint )value.Length )<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( value<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
			return;
		}

<#
	} // foreach spec

	// TODO: ReadOnlySpan<byte>
#>
		public <#= AsyncMethod( isAsync, "void", "PackExtendedTypeValue", "byte typeCode, byte[] body" ) #>
		{
			unchecked
			{
				switch ( body.Length )
				{
					case 1:
					{
						<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( Header.FixExt1<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						break;
					}
					case 2:
					{
						<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( Header.FixExt2<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						break;
					}
					case 4:
					{
						<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( Header.FixExt4<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						break;
					}
					case 8:
					{
						<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( Header.FixExt8<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						break;
					}
					case 16:
					{
						<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( Header.FixExt16<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						break;
					}
					default:
					{
						if ( body.Length < 0x100 )
						{
							<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Ext8, ( byte )body.Length<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						}
						else if ( body.Length < 0x10000 )
						{
							<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Ext16, ( ushort )body.Length<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						}
						else
						{
							<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( Header.Ext32, ( uint )body.Length<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
						}

						break;
					}
				} // switch
			} // unchecked

			<#= Await( isAsync ) #>this.Writer.WriteByte<#= Suffix( isAsync ) #>( typeCode<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
			<#= Await( isAsync ) #>this.Writer.WriteBytes<#= Suffix( isAsync ) #>( body<#= Argument( isAsync ) #> )<#= ConfigureAwait( isAsync ) #>;
		}

<#

	if ( isAsync )
	{
#>
#endif // FEATURE_TAP
<#
	}

} // foreach isAsync
#>
	}
}
<#+
private static string AsyncPack( Type type, bool isAsync, bool isNullable )
{
	return
		AsyncMethod(
			isAsync,
			"void",
			"Pack",
			String.Format(
				CultureInfo.InvariantCulture,
				"{0}{1} {2}",
				type.Name,
				isNullable ? "?" : String.Empty,
				isNullable ? "nullable" : "value"
			)
		);
}

private static string AsyncMethod( bool isAsync, string returnType, string name, string parameterList )
{
	var realReturnType = returnType;
	if ( isAsync )
	{
		realReturnType = "Task" + ( returnType == "void" ? String.Empty : ( "<" + returnType + ">" ) );
	}

	return
		String.Format(
			CultureInfo.InvariantCulture,
			"{0} {1}{2}( {3}{4} )",
			( isAsync ? "async " : String.Empty ) + realReturnType,
			name,
			isAsync ? "Async" : String.Empty,
			parameterList,
			isAsync ? ", CancellationToken cancellationToken" : String.Empty
		);
}

private static string Await( bool isAsync )
{
	return isAsync ? "await " : String.Empty;
}

private static string Suffix( bool isAsync )
{
	return isAsync ? "Async" : String.Empty;
}

private static string Argument( bool isAsync )
{
	return isAsync ? ", cancellationToken" : String.Empty;
}

private static string ConfigureAwait( bool isAsync )
{
	return isAsync ? ".ConfigureAwait( false )" : String.Empty;
}

private static string ToTypeName( bool isSigned, int bytes )
{
	switch ( bytes )
	{
		case 1:
		{
			return isSigned ? "SByte" : "Byte";
		}
		default:
		{
			return ( isSigned ? "Int" : "UInt" ) + ( bytes * 8 ).ToString( CultureInfo.InvariantCulture );
		}
	}
}

private static string ToUnsigned( Type type )
{
	switch ( type.Name )
	{
		case "Byte":
		case "UInt16":
		case "UInt32":
		case "UInt64":
		case "Single":
		case "Double":
		{
			return type.Name;
		}
		case "SByte":
		{
			return "Byte";
		}
		case "Int16":
		case "Int32":
		case "Int64":
		{
			return "U" + type.Name;
		}
		default:
		{
			throw new Exception( "unexpected type " + type );
		}
	}
}
#>
